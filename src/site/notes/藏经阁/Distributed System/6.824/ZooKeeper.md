---
{"title":"ZooKeeper","auther":"four1er","created_at":"2025-01-23 10:46","last modify":"2025-01-23 10:46","file path":"藏经阁/Distributed System/6.824/ZooKeeper.md","tags":["distributed_sytem","zookeeper"],"dg-publish":true,"permalink":"/藏经阁/Distributed System/6.824/ZooKeeper/","dgPassFrontmatter":true,"created":"2025-04-04T19:37:23.324+08:00","updated":"2025-04-04T19:37:23.325+08:00"}
---


# 线性一致
如果一个服务是线性一致的，那么它表现的就像只有一个服务器。一个线性一致系统中的执行历史中的操作是非并发的。
# 为什么要有 Zookeeper
这个标题还有另一个表达方式，Zookeeper 解决了什么问题？
在回答这个问题之前，我们先了解一下分布式系统的一个痛点问题。作为一个分布式系统，我们需要具有一定的容错处理，这意味着我们通常需要通过多副本来完成容错，所以一个 Zookeeper 可能会有 3 个、5 个或者 7 个服务器，而这些服务器是需要花钱的，很明显，一个 7 个节点的服务器集群是要比 1 个节点的 " 集群 " 贵 7 倍。
所以这里有个问题，如果花了 7 个服务器来运行多副本服务，那么是否能通过这 7 台服务器得到 7 倍的性能？

> [!attention]
> 在接下来的讨论中，我们将会把 Zookeeper 看成一个类似于 Raft 的多副本系统。Zookeeper 实际上运行在 Zab 之上，从我们的角度来看，Zab 几乎与 Raft 是一样的。并且这里我们只看多副本系统的性能，并不关心 Zookeeper 的具体功能。

现在，从全局来看，我们有大量的客户端，并且我们只有一个 Leader，这个 Leader 有两层，上面一层是与客户端交互的 Zookeeper，下面是与 Raft 类似的管理多副本的 Zab。Zab 所做的工作是维护用来存放一系列操作的 Log，这些操作是从客户端发送过来的，这与 Raft 非常相似。然后会有多个副本，每个副本都有自己的 Log，并且会将新的请求加到 Log 中。这是一个很熟悉的配置（与 Raft 是一样的）。
当一个客户端发送了一个请求，Zab 层会将这个请求的拷贝发送给其他的副本，其他副本会将请求追加在它们的内存中的 Log 或者是持久化存储在磁盘上，这样它们故障重启之后可以取回这些 Log。
现在的问题在于，当我们增加了大量的服务器，系统会变快吗？
答案是不会的。因为 Leader 节点是一个显而易见的瓶颈。因为 Leader 需要处理每一个请求，它需要将每个请求的拷贝发送给每一个其他服务器。当你添加更多的服务器时，你只是为现在的瓶颈（Leader 节点）添加了更多的工作负载。
或许有一个最简单的能利用这些服务器的方法：让 leader 节点只负责写指令的下发，而读请求则发给任意一个副本。

> [!faq] 我们直接将读请求发送给副本，这符合预期吗？
> 很明显，这里存在一个实时性的问题。我们没有理由相信，除了 Leader 以外的任何一个副本中的数据是最新的（up to date）。
> 有太多的可能导致副本没有最新的数据了，比如：这个副本可能不在 leader 所在的过半服务器中，又或者网络丢包了。

如果你看 Zookeeper 论文的表 2，Zookeeper 的读性能随着服务器数量的增加而显著的增加。所以，很明显，Zookeeper 这里有一些修改使得读请求可以由其他的服务器，其他的副本来处理。那么 Zookeeper 是如何确保这里的读请求是安全的（线性一致）？

![image.png|650](https://raw.githubusercontent.com/four1er/tuchuan/main/img/20250210214817.png)

对的，<font color="#ff0000">实际上，Zookeeper 并不要求返回最新的写入数据。Zookeeper 的方式是，放弃线性一致性。</font>
它对于这里问题的解决方法是，不提供线性一致的读。所以，因此，Zookeeper 也不用为读请求提供最新的数据。它有自己有关一致性的定义，而这个定义不是线性一致的，因此允许为读请求返回旧的数据。
所以，Zookeeper 这里声明，自己最开始就不支持线性一致性，来解决这里的技术问题。如果不提供这个能力，那么（为读请求返回旧数据）就不是一个 bug。这实际上是一种经典的解决性能和强一致之间矛盾的方法，也就是不提供强一致。

> [!question]
> 如果系统不提供线性一致性，那么系统是否还可用？客户端读不到最新的数据，那我们为什么要相信这个系统是可用的？这个问题将在接下来继续讨论。

> [!summary]
> Zookeeper 允许客户端将读请求发送给任意副本，并有副本根据自己的状态来响应读请求。

# 一致性保证 Consistency Guarantees
ZooKeeper 有两个主要的保证。
1. 写请求是线性一致的。
2. FIFO 客户端序列。

对于第一点：写请求线性一致。Zookeeper 只考虑写，不考虑读，这里的意思是，尽管客户端可以并发的发送写请求，然后 Zookeeper 表现的就像以某种顺序，一次只执行一个写请求，并且也符合写请求的实际时间。所以如果一个写请求在另一个写请求开始前就结束了，那么 Zookeeper 实际上也会先执行第一个写请求，再执行第二个写请求。
对于第二点：任何一个客户端的请求，都会按照客户端指定的顺序来执行，论文里称之为 FIFO 客户端序列。这里的意思是，如果一个特定的客户端发送了一个写请求之后是一个读请求或者任意请求，那么所有的写请求会以客户端发送的相对顺序，加入到客户端的写请求中。
对于读请求要复杂一点。后来的读请求不允许看到之前的状态，第二个读请求至少要能看到第一个读请求的状态。这里有一个很有意思的问题，如果一个客户端正在与一个副本交互，客户端发送了一些读请求给这个副本，之后这个副本故障了，客户端需要将读请求发送给另一个副本。这时，尽管客户端切换到了一个新的副本，FIFO 客户端序列仍然有效。例如：
```text
S1 A B <--
S2 A B C
```

客户端在读 S1 的时候读到了 B 位置，S1 故障了，客户端去读 S2，S2 给它的响应也必须在 B 点之后。
这里工作的原理是，每个 Log 条目都会被 Leader 打上 zxid 的标签，这些标签就是 Log 对应的条目号。任何时候一个副本回复一个客户端的读请求，首先这个读请求是在 Log 的某个特定点执行的，其次回复里面会带上 zxid，对应的就是 Log 中执行点的前一条 Log 条目号。客户端会记住最高的 zxid，当客户端发出一个请求到一个相同或者不同的副本时，它会在它的请求中带上这个最高的 zxid。这样，其他的副本就知道，应该至少在 Log 中这个点或者之后执行这个读请求。

> [!question] 如果 S2 没有最新的 log 怎么办？

那么在获取到对应这个位置的 Log 之前，这个副本不能响应客户端请求。
要么副本阻塞了对于客户端的响应，要么副本拒绝了客户端的读请求并说：我并不了解这些信息，去问问其他的副本，或者过会再来问我。
最终，如果这个副本连上了 Leader，它会更新上最新的 Log，到那个时候，这个副本就可以响应读请求了。好的，所以读请求都是有序的，它们的顺序与时间正相关。
更进一步来说，FIFI 客户端请求序列是对一个客户端的所有读请求、写请求生效。所以如果我发送了一个写请求给 Leader，在 Leader commit 这个请求之前需要消耗一些时间，之后又发送了一个读请求给副本，这个读请求需要暂缓一下，以确保 FIFO 客户端请求序列。读请求需要暂缓，直到这个副本发现之前的写请求已经执行了。这是 FIFO 客户端请求序列的必然结果，（对于某个特定的客户端）读写请求是线性一致的。
最明显的理解这种行为的方式是，如果一个客户端写了一份数据，例如向 Leader 发送了一个写请求，之后立即读同一份数据，并将读请求发送给了某一个副本，那么客户端需要看到自己刚刚写入的值。如果我写了某个变量为 17，那么我之后读这个变量，返回的不是 17，这会很奇怪，这表明系统并没有执行我的请求。因为如果执行了的话，写请求应该在读请求之前执行。所以，副本必然有一些有意思的行为来暂缓客户端，比如当客户端发送一个读请求说，我上一次发送给 Leader 的写请求对应了 zxid 是多少，这个副本必须等到自己看到对应 zxid 的写请求再执行读请求。

> 用更简单的话解释就是，同一个客户端，读写是顺序的。写后的读，必定能读到写的内容。但是对于多个客户度，A 写请求，B 读请求，可能 B 会读不到 A 写的值。
> 这个是由客户端的 zxid 来保证的。

> [!summary] Zookeeper 可以保证单个客户端的请求是线性一致的。

# 同步操作
Zookeeper 中有一个 sync 操作类型，可以读出最新的数据。
如果我想读到最新的数据，我可以先发送一个 sync 请求，它的效果相当于一个写请求，它最终会出现在所有的副本 log 中。尽管我只关心与我交互的副本，但是这个操作会同步到所有的副本。
接下来再发送读请求时，cli 告诉副本，在看到我上一次 sync 请求之前，不要返回我的 read 请求。
如果这里把 sync 看成是一个写请求，这里实际上符合了 FIFO 客户端请求序列，因为读请求必须至少要看到同一个客户端前一个写请求对应的状态。
# 就绪文件 Ready file/znode
我们假设有另外一个分布式系统，这个分布式有一个 Master 节点，而 Master 节点在 Zookeeper 中维护了一个配置，这个配置对应了一些 file（也就是 znode）。通过这个配置，描述了有关分布式系统的一些信息，例如所有 worker 的 IP 地址，或者当前谁是 Master。所以，现在 Master 在更新这个配置，同时，或许有大量的客户端需要读取相应的配置，并且需要发现配置的每一次变化。所以，现在的问题是，配置被分割成了多个 file，我们还能有原子效果的更新吗？
为什么要有原子效果的更新呢？因为只有这样，其他的客户端才能读出完整更新的配置，而不是读出更新了一半的配置。这是人们使用 Zookeeper 管理配置文件时的一个经典场景。
假设 Master 做了一系列写请求来更新配置，那么我们的分布式系统中的 Master 会以这种顺序执行写请求。首先我们假设有一些 Ready file，就是以 Ready 为名字的 file。如果 Ready file 存在，那么允许读这个配置。如果 Ready file 不存在，那么说明配置正在更新过程中，我们不应该读取配置。
所以，如果 Master 要更新配置，那么第一件事情是删除 Ready file。之后它会更新各个保存了配置的 Zookeeper file（也就是 znode），这里或许有很多的 file。当所有组成配置的 file 都更新完成之后，Master 会再次创建 Ready file。目前为止，这里的语句都很直观，这里只有写请求，没有读请求，而 Zookeeper 中写请求可以确保以线性顺序执行。
为了确保这里的执行顺序，Master 以某种方式为这些请求打上了 tag，表明了对于这些写请求期望的执行顺序。之后 Zookeeper Leader 需要按照这个顺序将这些写请求加到多副本的 Log 中。
接下来，所有的副本会履行自己的职责，按照这里的顺序一条条执行请求。它们也会删除（自己的）Ready file，之后执行这两个写请求，最后再次创建（自己的）Ready file。所以，这里是写请求，顺序还是很直观的。
对于读请求来说。假设我们有一些 worker 节点需要读取当前的配置。我们可以假设 Worker 节点首先会检查 Ready file 是否存在。如果不存在，那么 Worker 节点会过一会再重试。所以，我们假设 Ready file 存在，并且是经历过一次重新创建。之后，如果文件存在，那么客户端会接下来读 f1 和 f2。
这里，有关 FIFO 客户端序列中有意思的地方是，如果判断 Ready file 的确存在，那么也是从与客户端交互的那个副本得出的判断。所以，这里通过读请求发现 Ready file 存在，可以说明那个副本看到了 Ready file 的重新创建这个请求（由 Leader 同步过来的）。
但是这里还是存在一些问题。
考虑如下场景：
假设 Master 在完成配置更新之后创建了 Ready file, 之后 master 又要更新配置，那么它又需要将 ready file 删除，之后再执行一些写请求。
这里可能有的问题是，需要读取配置的客户端，首先会在这个点，通过调用 exist 来判断 Ready file 是否存在。在某个时间点，Ready file 是存在的。之后，随着时间的推移，客户端读取了组成配置的第一个 file，但是，之后在读取第二个 file 时，Master 可能正在更新配置。所以现在客户端读到的是一个不正常的，由旧配置的 f1 和新配置的 f2 组成的配置。
Zookeeper 的 API 实际上设计的非常巧妙，它可以处理这里的问题。之前说过，客户端会发送 exists 请求来查询，Ready file 是否存在。但是实际上，客户端不仅会查询 Ready file 是否存在，还会建立一个针对这个 Ready file 的 watch。
这意味着如果 Ready file 有任何变更，例如，被删除了，或者它之前不存在然后被创建了，副本会给客户端发送一个通知。在这个场景中，如果 Ready file 被删除了，副本会给客户端发送一个通知。
Zookeeper 可以保证，如果客户端向某个副本 watch 了某个 Ready file，之后又发送了一些读请求，当这个副本执行了一些会触发 watch 通知的请求，那么 Zookeeper 可以确保副本将 watch 对应的通知，先发给客户端，再处理触发 watch 通知请求（也就是删除 Ready file 的请求），在 Log 中位置之后才执行的读请求（有点绕，后面会有更多的解释）。
在这个例子中说明就是，如果我们之前设置好了 watch，Zookeeper 可以保证如果某个人删除了 Ready file，它会产生一个通知，这个通知可以确保在读 f2 的请求响应之前发送给客户端。
客户端在完成读所有的配置之前，如果对配置有了新的更改，Zookeeper 可以保证客户端在收到删除 Ready file 的通知之前，看到的都是配置更新前的数据。

> [!summary] 也就是说，客户端读取配置读了一半，如果收到了 Ready file 删除的通知，就可以放弃这次读，再重试读了

# Zookeeper API
Zookeeper 的 API 某种程度上来说像是一个文件系统。它有一个层级化的目录结构，有一个根目录 root，之后每个应用程序有自己的子目录。
比如说应用程序 1 将自己的文件保存在 APP1 目录下，应用程序 2 将自己的文件保存在 APP2 目录下，这些目录又可以包含文件和其他的目录。

> [!note] 为什么要这么设计？
> 因为 Zookeeper 需要考虑到被许多可能完全不相关的服务共享使用。所以需要一个命名系统来区分不同服务的信息。

所以 Zookeeper 的 API 看起来像是一个文件系统，但又不是一个实际的文件系统，只是在内部以路径名的形式命名各种对象。
假设应用程序 2 下面有 X，Y，Z 这些文件。当你通过 RPC 向 Zookeeper 请求数据时，你可以直接指定/APP2/X。这就是一种层级化的命名方式。
这里的文件和目录都被称为 znodes。Zookeeper 中包含了 3 种类型的 znode，了解他们对于解决问题会有帮助。
1. 第一种 Regular znodes。这种 znode 一旦创建，就永久存在，除非你删除了它。
2. 第二种是 Ephemeral znodes。如果 Zookeeper 认为创建它的客户端挂了，它会删除这种类型的 znodes。这种类型的 znodes 与客户端会话绑定在一起，所以客户端需要时不时的发送心跳给 Zookeeper，告诉 Zookeeper 自己还活着，这样 Zookeeper 才不会删除客户端对应的 ephemeral znodes。
3. 最后一种类型是 Sequential znodes。它的意思是，当你想要以特定的名字创建一个文件，Zookeeper 实际上创建的文件名是你指定的文件名再加上一个数字。当有多个客户端同时创建 Sequential 文件时，Zookeeper 会确保这里的数字不重合，同时也会确保这里的数字总是递增的。

Zookeeper 以 RPC 的方式暴露以下 API。
- `CREATE(PATH，DATA，FLAG)`。入参分别是文件的全路径名 PATH，数据 DATA，和表明 znode 类型的 FLAG。这里有意思的是，CREATE 的语义是排他的。也就是说，如果我向 Zookeeper 请求创建一个文件，如果我得到了 yes 的返回，那么说明这个文件之前不存在，我是第一个创建这个文件的客户端；如果我得到了 no 或者一个错误的返回，那么说明这个文件之前已经存在了。所以，客户端知道文件的创建是排他的。在后面有关锁的例子中，我们会看到，如果有多个客户端同时创建同一个文件，实际成功创建文件（获得了锁）的那个客户端是可以通过 CREATE 的返回知道的。
- `DELETE(PATH，VERSION)`。入参分别是文件的全路径名 PATH，和版本号 VERSION。有一件事情我之前没有提到，每一个 znode 都有一个表示当前版本号的 version，当 znode 有更新时，version 也会随之增加。对于 delete 和一些其他的 update 操作，你可以增加一个 version 参数，表明当且仅当 znode 的当前版本号与传入的 version 相同，才执行操作。当存在多个客户端同时要做相同的操作时，这里的参数 version 会非常有帮助（并发操作不会被覆盖）。所以，对于 delete，你可以传入一个 version 表明，只有当 znode 版本匹配时才删除。
- `EXIST(PATH，WATCH)`。入参分别是文件的全路径名 PATH，和一个有趣的额外参数 WATCH。通过指定 watch，你可以监听对应文件的变化。不论文件是否存在，你都可以设置 watch 为 true，这样 Zookeeper 可以确保如果文件有任何变更，例如创建，删除，修改，都会通知到客户端。此外，判断文件是否存在和 watch 文件的变化，在 Zookeeper 内是原子操作。所以，当调用 exist 并传入 watch 为 true 时，不可能在 Zookeeper 实际判断文件是否存在，和建立 watch 通道之间，插入任何的创建文件的操作，这对于正确性来说非常重要。
- `GETDATA(PATH，WATCH)`。入参分别是文件的全路径名 PATH，和 WATCH 标志位。这里的 watch 监听的是文件的内容的变化。
- `SETDATA(PATH，DATA，VERSION)`。入参分别是文件的全路径名 PATH，数据 DATA，和版本号 VERSION。如果你传入了 version，那么 Zookeeper 当且仅当文件的版本号与传入的 version 一致时，才会更新文件。
- `LIST(PATH)`。入参是目录的路径名，返回的是路径下的所有文件。
