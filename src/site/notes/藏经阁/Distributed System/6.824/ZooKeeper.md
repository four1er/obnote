---
{"title":"ZooKeeper","auther":"four1er","created_at":"2025-01-23 10:46","last modify":"2025-01-23 10:46","file path":"藏经阁/Distributed System/6.824/ZooKeeper.md","tags":["distributed_sytem","zookeeper"],"dg-publish":true,"permalink":"/藏经阁/Distributed System/6.824/ZooKeeper/","dgPassFrontmatter":true,"created":"2025-02-05T10:35:59.677+08:00","updated":"2025-02-11T12:03:35.629+08:00"}
---

# 线性一致
如果一个服务是线性一致的，那么它表现的就像只有一个服务器。一个线性一致系统中的执行历史中的操作是非并发的。
# 为什么要有 Zookeeper
这个标题还有另一个表达方式，Zookeeper 解决了什么问题？
在回答这个问题之前，我们先了解一下分布式系统的一个痛点问题。作为一个分布式系统，我们需要具有一定的容错处理，这意味着我们通常需要通过多副本来完成容错，所以一个 Zookeeper 可能会有 3 个、5 个或者 7 个服务器，而这些服务器是需要花钱的，很明显，一个 7 个节点的服务器集群是要比 1 个节点的 " 集群 " 贵 7 倍。
所以这里有个问题，如果花了 7 个服务器来运行多副本服务，那么是否能通过这 7 台服务器得到 7 倍的性能？

> [!attention]
> 在接下来的讨论中，我们将会把 Zookeeper 看成一个类似于 Raft 的多副本系统。Zookeeper 实际上运行在 Zab 之上，从我们的角度来看，Zab 几乎与 Raft 是一样的。并且这里我们只看多副本系统的性能，并不关心 Zookeeper 的具体功能。

现在，从全局来看，我们有大量的客户端，并且我们只有一个 Leader，这个 Leader 有两层，上面一层是与客户端交互的 Zookeeper，下面是与 Raft 类似的管理多副本的 Zab。Zab 所做的工作是维护用来存放一系列操作的 Log，这些操作是从客户端发送过来的，这与 Raft 非常相似。然后会有多个副本，每个副本都有自己的 Log，并且会将新的请求加到 Log 中。这是一个很熟悉的配置（与 Raft 是一样的）。
当一个客户端发送了一个请求，Zab 层会将这个请求的拷贝发送给其他的副本，其他副本会将请求追加在它们的内存中的 Log 或者是持久化存储在磁盘上，这样它们故障重启之后可以取回这些 Log。
现在的问题在于，当我们增加了大量的服务器，系统会变快吗？
答案是不会的。因为 Leader 节点是一个显而易见的瓶颈。因为 Leader 需要处理每一个请求，它需要将每个请求的拷贝发送给每一个其他服务器。当你添加更多的服务器时，你只是为现在的瓶颈（Leader 节点）添加了更多的工作负载。
或许有一个最简单的能利用这些服务器的方法：让 leader 节点只负责写指令的下发，而读请求则发给任意一个副本。

> [!faq] 我们直接将读请求发送给副本，这符合预期吗？
> 很明显，这里存在一个实时性的问题。我们没有理由相信，除了 Leader 以外的任何一个副本中的数据是最新的（up to date）。
> 有太多的可能导致副本没有最新的数据了，比如：这个副本可能不在 leader 所在的过半服务器中，又或者网络丢包了。

如果你看 Zookeeper 论文的表 2，Zookeeper 的读性能随着服务器数量的增加而显著的增加。所以，很明显，Zookeeper 这里有一些修改使得读请求可以由其他的服务器，其他的副本来处理。那么 Zookeeper 是如何确保这里的读请求是安全的（线性一致）？

![image.png|650](https://raw.githubusercontent.com/four1er/tuchuan/main/img/20250210214817.png)

对的，<font color="#ff0000">实际上，Zookeeper 并不要求返回最新的写入数据。Zookeeper 的方式是，放弃线性一致性。</font>
它对于这里问题的解决方法是，不提供线性一致的读。所以，因此，Zookeeper 也不用为读请求提供最新的数据。它有自己有关一致性的定义，而这个定义不是线性一致的，因此允许为读请求返回旧的数据。
所以，Zookeeper 这里声明，自己最开始就不支持线性一致性，来解决这里的技术问题。如果不提供这个能力，那么（为读请求返回旧数据）就不是一个 bug。这实际上是一种经典的解决性能和强一致之间矛盾的方法，也就是不提供强一致。

> [!question]
> 如果系统不提供线性一致性，那么系统是否还可用？客户端读不到最新的数据，那我们为什么要相信这个系统是可用的？这个问题将在接下来继续讨论。

> [!summary]
> Zookeeper 允许客户端将读请求发送给任意副本，并有副本根据自己的状态来响应读请求。

# 一致性保证 Consistency Guarantees
ZooKeeper 有两个主要的保证。
1. 写请求是线性一致的。
2. FIFO 客户端序列。

对于第一点：写请求线性一致。Zookeeper 只考虑写，不考虑读，这里的意思是，尽管客户端可以并发的发送写请求，然后 Zookeeper 表现的就像以某种顺序，一次只执行一个写请求，并且也符合写请求的实际时间。所以如果一个写请求在另一个写请求开始前就结束了，那么 Zookeeper 实际上也会先执行第一个写请求，再执行第二个写请求。
对于第二点：任何一个客户端的请求，都会按照客户端指定的顺序来执行，论文里称之为 FIFO 客户端序列。这里的意思是，如果一个特定的客户端发送了一个写请求之后是一个读请求或者任意请求，那么所有的写请求会以客户端发送的相对顺序，加入到客户端的写请求中。
对于读请求要复杂一点。后来的读请求不允许看到之前的状态，第二个读请求至少要能看到第一个读请求的状态。这里有一个很有意思的问题，如果一个客户端正在与一个副本交互，客户端发送了一些读请求给这个副本，之后这个副本故障了，客户端需要将读请求发送给另一个副本。这时，尽管客户端切换到了一个新的副本，FIFO 客户端序列仍然有效。例如：
```text
S1 A B <--
S2 A B C
```

客户端在读 S1 的时候读到了 B 位置，S1 故障了，客户端去读 S2，S2 给它的响应也必须在 B 点之后。
这里工作的原理是，每个 Log 条目都会被 Leader 打上 zxid 的标签，这些标签就是 Log 对应的条目号。任何时候一个副本回复一个客户端的读请求，首先这个读请求是在 Log 的某个特定点执行的，其次回复里面会带上 zxid，对应的就是 Log 中执行点的前一条 Log 条目号。客户端会记住最高的 zxid，当客户端发出一个请求到一个相同或者不同的副本时，它会在它的请求中带上这个最高的 zxid。这样，其他的副本就知道，应该至少在 Log 中这个点或者之后执行这个读请求。

> [!question] 如果 S2 没有最新的 log 怎么办？

那么在获取到对应这个位置的 Log 之前，这个副本不能响应客户端请求。
要么副本阻塞了对于客户端的响应，要么副本拒绝了客户端的读请求并说：我并不了解这些信息，去问问其他的副本，或者过会再来问我。
最终，如果这个副本连上了 Leader，它会更新上最新的 Log，到那个时候，这个副本就可以响应读请求了。好的，所以读请求都是有序的，它们的顺序与时间正相关。
更进一步来说，FIFI 客户端请求序列是对一个客户端的所有读请求、写请求生效。所以如果我发送了一个写请求给 Leader，在 Leader commit 这个请求之前需要消耗一些时间，之后又发送了一个读请求给副本，这个读请求需要暂缓一下，以确保 FIFO 客户端请求序列。读请求需要暂缓，直到这个副本发现之前的写请求已经执行了。这是 FIFO 客户端请求序列的必然结果，（对于某个特定的客户端）读写请求是线性一致的。
最明显的理解这种行为的方式是，如果一个客户端写了一份数据，例如向 Leader 发送了一个写请求，之后立即读同一份数据，并将读请求发送给了某一个副本，那么客户端需要看到自己刚刚写入的值。如果我写了某个变量为 17，那么我之后读这个变量，返回的不是 17，这会很奇怪，这表明系统并没有执行我的请求。因为如果执行了的话，写请求应该在读请求之前执行。所以，副本必然有一些有意思的行为来暂缓客户端，比如当客户端发送一个读请求说，我上一次发送给 Leader 的写请求对应了 zxid 是多少，这个副本必须等到自己看到对应 zxid 的写请求再执行读请求。

> 用更简单的话解释就是，同一个客户端，读写是顺序的。写后的读，必定能读到写的内容。但是对于多个客户度，A 写请求，B 读请求，可能 B 会读不到 A 写的值。
> 这个是由客户端的 zxid 来保证的。

> [!summary] Zookeeper 可以保证单个客户端的请求是线性一致的。

发的
